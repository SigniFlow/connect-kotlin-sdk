/**
* SigniFlow OpenAPI Spec v1
* ## SigniFlow API used to automate esignature workflow creation and management. 
*
* The version of the OpenAPI document: 1.0
* Contact: support@signiflow.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package SigniFlow.Connect.apis

import SigniFlow.Connect.models.LoginRequest
import SigniFlow.Connect.models.LoginResponse
import SigniFlow.Connect.models.LogoutRequest
import SigniFlow.Connect.models.LogoutResponse
import SigniFlow.Connect.models.TokenExtendRequest
import SigniFlow.Connect.models.TokenExtendResponse
import SigniFlow.Connect.models.TokenValidateRequest
import SigniFlow.Connect.models.TokenValidateResponse

import SigniFlow.Connect.infrastructure.ApiClient
import SigniFlow.Connect.infrastructure.ClientException
import SigniFlow.Connect.infrastructure.ClientError
import SigniFlow.Connect.infrastructure.ServerException
import SigniFlow.Connect.infrastructure.ServerError
import SigniFlow.Connect.infrastructure.MultiValueMap
import SigniFlow.Connect.infrastructure.RequestConfig
import SigniFlow.Connect.infrastructure.RequestMethod
import SigniFlow.Connect.infrastructure.ResponseType
import SigniFlow.Connect.infrastructure.Success
import SigniFlow.Connect.infrastructure.toMultiValue

class AuthenticationApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("SigniFlow.Connect.baseUrl", "https://server-url/API/SignFlowAPIServiceRest.svc")
        }
    }

    /**
    * Login
    * #### Generates a API Token for the User
    * @param contentType  
    * @param loginRequest ##### Login Request Model 
    * @return LoginResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun login(contentType: kotlin.String, loginRequest: LoginRequest) : LoginResponse {
        val localVariableConfig = loginRequestConfig(contentType = contentType, loginRequest = loginRequest)

        val localVarResponse = request<LoginResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LoginResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation login
    *
    * @param contentType  
    * @param loginRequest ##### Login Request Model 
    * @return RequestConfig
    */
    fun loginRequestConfig(contentType: kotlin.String, loginRequest: LoginRequest) : RequestConfig {
        val localVariableBody: kotlin.Any? = loginRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/Login",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Logout
    * #### Used to log out a user from SigniFlow.
    * @param contentType  
    * @param logoutRequest ##### Logout Request Model (optional)
    * @return LogoutResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postLogout(contentType: kotlin.String, logoutRequest: LogoutRequest?) : LogoutResponse {
        val localVariableConfig = postLogoutRequestConfig(contentType = contentType, logoutRequest = logoutRequest)

        val localVarResponse = request<LogoutResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LogoutResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postLogout
    *
    * @param contentType  
    * @param logoutRequest ##### Logout Request Model (optional)
    * @return RequestConfig
    */
    fun postLogoutRequestConfig(contentType: kotlin.String, logoutRequest: LogoutRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = logoutRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/Logout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Token Extend
    * #### Used to extend the period of time in which the session token is valid.
    * @param contentType  
    * @param tokenExtendRequest ##### Token Extend Request Model (optional)
    * @return TokenExtendResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTokenExtend(contentType: kotlin.String, tokenExtendRequest: TokenExtendRequest?) : TokenExtendResponse {
        val localVariableConfig = postTokenExtendRequestConfig(contentType = contentType, tokenExtendRequest = tokenExtendRequest)

        val localVarResponse = request<TokenExtendResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenExtendResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postTokenExtend
    *
    * @param contentType  
    * @param tokenExtendRequest ##### Token Extend Request Model (optional)
    * @return RequestConfig
    */
    fun postTokenExtendRequestConfig(contentType: kotlin.String, tokenExtendRequest: TokenExtendRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = tokenExtendRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/TokenExtend",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Token Validate
    * #### Used to validate the user&#39;s session token.
    * @param contentType  
    * @param tokenValidateRequest ##### Token Validate Request Model (optional)
    * @return TokenValidateResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTokenValidate(contentType: kotlin.String, tokenValidateRequest: TokenValidateRequest?) : TokenValidateResponse {
        val localVariableConfig = postTokenValidateRequestConfig(contentType = contentType, tokenValidateRequest = tokenValidateRequest)

        val localVarResponse = request<TokenValidateResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenValidateResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postTokenValidate
    *
    * @param contentType  
    * @param tokenValidateRequest ##### Token Validate Request Model (optional)
    * @return RequestConfig
    */
    fun postTokenValidateRequestConfig(contentType: kotlin.String, tokenValidateRequest: TokenValidateRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = tokenValidateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/TokenValidate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

}
