/**
* SigniFlow OpenAPI Spec v1
* ## SigniFlow API used to automate esignature workflow creation and management. 
*
* The version of the OpenAPI document: 1.0
* Contact: support@signiflow.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package SigniFlow.Connect.apis

import SigniFlow.Connect.models.AddWokflowStepV2Response
import SigniFlow.Connect.models.AddWorkflowStepV2Request
import SigniFlow.Connect.models.CancelFlowRequest
import SigniFlow.Connect.models.CancelFlowResponse
import SigniFlow.Connect.models.CreateWorkflowRequest
import SigniFlow.Connect.models.CreateWorkflowResponse
import SigniFlow.Connect.models.DeleteDocRequest
import SigniFlow.Connect.models.DeleteDocResponse
import SigniFlow.Connect.models.DocPrepperAddAdvancedFieldsRequest
import SigniFlow.Connect.models.DocPrepperAddAdvancedFieldsResponse
import SigniFlow.Connect.models.DocPrepperAddFieldsFlowIDRequest
import SigniFlow.Connect.models.DocPrepperAddFieldsFlowIDResponse
import SigniFlow.Connect.models.FullWorkflowRequest
import SigniFlow.Connect.models.FullWorkflowResponse
import SigniFlow.Connect.models.GetDocStatusRequest
import SigniFlow.Connect.models.GetDocStatusResponse
import SigniFlow.Connect.models.GetDocumentRequest
import SigniFlow.Connect.models.GetDocumentResponse
import SigniFlow.Connect.models.InitiateFlowNoEmailRequest
import SigniFlow.Connect.models.InitiateFlowNoEmailResponse
import SigniFlow.Connect.models.InitiateFlowNoInitialEmailRequest
import SigniFlow.Connect.models.InitiateFlowNoInitialEmailResponse
import SigniFlow.Connect.models.InitiateFlowRequest
import SigniFlow.Connect.models.InitiateFlowResponse
import SigniFlow.Connect.models.WorkflowSignRequest
import SigniFlow.Connect.models.WorkflowSignResponse

import SigniFlow.Connect.infrastructure.ApiClient
import SigniFlow.Connect.infrastructure.ClientException
import SigniFlow.Connect.infrastructure.ClientError
import SigniFlow.Connect.infrastructure.ServerException
import SigniFlow.Connect.infrastructure.ServerError
import SigniFlow.Connect.infrastructure.MultiValueMap
import SigniFlow.Connect.infrastructure.RequestConfig
import SigniFlow.Connect.infrastructure.RequestMethod
import SigniFlow.Connect.infrastructure.ResponseType
import SigniFlow.Connect.infrastructure.Success
import SigniFlow.Connect.infrastructure.toMultiValue

class WorkFlowApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("SigniFlow.Connect.baseUrl", "https://server-url/API/SignFlowAPIServiceRest.svc")
        }
    }

    /**
    * Create Workflow
    * #### Used to start a new workflow by passing a Base64 encoded document to SigniFlow
    * @param contentType  
    * @param createWorkflowRequest ##### Create Workflow Request Model 
    * @return CreateWorkflowResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createWorkflow(contentType: kotlin.String, createWorkflowRequest: CreateWorkflowRequest) : CreateWorkflowResponse {
        val localVariableConfig = createWorkflowRequestConfig(contentType = contentType, createWorkflowRequest = createWorkflowRequest)

        val localVarResponse = request<CreateWorkflowResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateWorkflowResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createWorkflow
    *
    * @param contentType  
    * @param createWorkflowRequest ##### Create Workflow Request Model 
    * @return RequestConfig
    */
    fun createWorkflowRequestConfig(contentType: kotlin.String, createWorkflowRequest: CreateWorkflowRequest) : RequestConfig {
        val localVariableBody: kotlin.Any? = createWorkflowRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/CreateWorkflow",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Get Document
    * #### Used to download a document from SigniFlow.
    * @param contentType  
    * @param getDocumentRequest ##### Get Document Request Model (optional)
    * @return GetDocumentResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDocument(contentType: kotlin.String, getDocumentRequest: GetDocumentRequest?) : GetDocumentResponse {
        val localVariableConfig = getDocumentRequestConfig(contentType = contentType, getDocumentRequest = getDocumentRequest)

        val localVarResponse = request<GetDocumentResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetDocumentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getDocument
    *
    * @param contentType  
    * @param getDocumentRequest ##### Get Document Request Model (optional)
    * @return RequestConfig
    */
    fun getDocumentRequestConfig(contentType: kotlin.String, getDocumentRequest: GetDocumentRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = getDocumentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/GetDoc",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Add a Workflow step
    * #### Used to add a step to a document Workflow process.
    * @param contentType  
    * @param addWorkflowStepV2Request ##### Add A Workflow Step Request Model (optional)
    * @return AddWokflowStepV2Response
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postAddWorkflowStep(contentType: kotlin.String, addWorkflowStepV2Request: AddWorkflowStepV2Request?) : AddWokflowStepV2Response {
        val localVariableConfig = postAddWorkflowStepRequestConfig(contentType = contentType, addWorkflowStepV2Request = addWorkflowStepV2Request)

        val localVarResponse = request<AddWokflowStepV2Response>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddWokflowStepV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postAddWorkflowStep
    *
    * @param contentType  
    * @param addWorkflowStepV2Request ##### Add A Workflow Step Request Model (optional)
    * @return RequestConfig
    */
    fun postAddWorkflowStepRequestConfig(contentType: kotlin.String, addWorkflowStepV2Request: AddWorkflowStepV2Request?) : RequestConfig {
        val localVariableBody: kotlin.Any? = addWorkflowStepV2Request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/AddWorkflowStepV2",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Cancel Flow
    * #### Used to cancel a document workflow.
    * @param contentType  
    * @param cancelFlowRequest ##### Cancel Flow Request Model (optional)
    * @return CancelFlowResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postCancelFlow(contentType: kotlin.String, cancelFlowRequest: CancelFlowRequest?) : CancelFlowResponse {
        val localVariableConfig = postCancelFlowRequestConfig(contentType = contentType, cancelFlowRequest = cancelFlowRequest)

        val localVarResponse = request<CancelFlowResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CancelFlowResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postCancelFlow
    *
    * @param contentType  
    * @param cancelFlowRequest ##### Cancel Flow Request Model (optional)
    * @return RequestConfig
    */
    fun postCancelFlowRequestConfig(contentType: kotlin.String, cancelFlowRequest: CancelFlowRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = cancelFlowRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/CancelFlow",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Delete Document
    * #### This is used to delete a document.
    * @param contentType  
    * @param deleteDocRequest ##### Delete Document Request Model (optional)
    * @return DeleteDocResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postDeleteDoc(contentType: kotlin.String, deleteDocRequest: DeleteDocRequest?) : DeleteDocResponse {
        val localVariableConfig = postDeleteDocRequestConfig(contentType = contentType, deleteDocRequest = deleteDocRequest)

        val localVarResponse = request<DeleteDocResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteDocResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postDeleteDoc
    *
    * @param contentType  
    * @param deleteDocRequest ##### Delete Document Request Model (optional)
    * @return RequestConfig
    */
    fun postDeleteDocRequestConfig(contentType: kotlin.String, deleteDocRequest: DeleteDocRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = deleteDocRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/DeleteDoc",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Document Prepper Add Fields
    * #### Used to add fields to a document using the user&#39;s FlowID.
    * @param contentType  
    * @param docPrepperAddFieldsFlowIDRequest ##### Document Prepper Add Fields Request Model (optional)
    * @return DocPrepperAddFieldsFlowIDResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postDocPrepperAddField(contentType: kotlin.String, docPrepperAddFieldsFlowIDRequest: DocPrepperAddFieldsFlowIDRequest?) : DocPrepperAddFieldsFlowIDResponse {
        val localVariableConfig = postDocPrepperAddFieldRequestConfig(contentType = contentType, docPrepperAddFieldsFlowIDRequest = docPrepperAddFieldsFlowIDRequest)

        val localVarResponse = request<DocPrepperAddFieldsFlowIDResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DocPrepperAddFieldsFlowIDResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postDocPrepperAddField
    *
    * @param contentType  
    * @param docPrepperAddFieldsFlowIDRequest ##### Document Prepper Add Fields Request Model (optional)
    * @return RequestConfig
    */
    fun postDocPrepperAddFieldRequestConfig(contentType: kotlin.String, docPrepperAddFieldsFlowIDRequest: DocPrepperAddFieldsFlowIDRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = docPrepperAddFieldsFlowIDRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/DocPrepperAddFieldsFlowID",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Document Prepper Add Advanced Fields
    * #### Used to add advanced fields to a document.
    * @param contentType  
    * @param docPrepperAddAdvancedFieldsRequest ##### Document Prepper Add Advanced Fields Request Model (optional)
    * @return DocPrepperAddAdvancedFieldsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postDocPrepperAdvancedFields(contentType: kotlin.String, docPrepperAddAdvancedFieldsRequest: DocPrepperAddAdvancedFieldsRequest?) : DocPrepperAddAdvancedFieldsResponse {
        val localVariableConfig = postDocPrepperAdvancedFieldsRequestConfig(contentType = contentType, docPrepperAddAdvancedFieldsRequest = docPrepperAddAdvancedFieldsRequest)

        val localVarResponse = request<DocPrepperAddAdvancedFieldsResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DocPrepperAddAdvancedFieldsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postDocPrepperAdvancedFields
    *
    * @param contentType  
    * @param docPrepperAddAdvancedFieldsRequest ##### Document Prepper Add Advanced Fields Request Model (optional)
    * @return RequestConfig
    */
    fun postDocPrepperAdvancedFieldsRequestConfig(contentType: kotlin.String, docPrepperAddAdvancedFieldsRequest: DocPrepperAddAdvancedFieldsRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = docPrepperAddAdvancedFieldsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/DocPrepperAdvancedFields",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * FullWorkflow
    * #### Used to create a fullworkflow for a document.
    * @param contentType  
    * @param fullWorkflowRequest ##### FullWorkflow Request Model (optional)
    * @return FullWorkflowResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postFullWorkflow(contentType: kotlin.String, fullWorkflowRequest: FullWorkflowRequest?) : FullWorkflowResponse {
        val localVariableConfig = postFullWorkflowRequestConfig(contentType = contentType, fullWorkflowRequest = fullWorkflowRequest)

        val localVarResponse = request<FullWorkflowResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FullWorkflowResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postFullWorkflow
    *
    * @param contentType  
    * @param fullWorkflowRequest ##### FullWorkflow Request Model (optional)
    * @return RequestConfig
    */
    fun postFullWorkflowRequestConfig(contentType: kotlin.String, fullWorkflowRequest: FullWorkflowRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = fullWorkflowRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/FullWorkflow",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Get Document Status
    * #### Used to get the status of the document ex. pending/completed/rejected.
    * @param contentType  
    * @param getDocStatusRequest ##### Get Document Status Request Model (optional)
    * @return GetDocStatusResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postGetDocStatus(contentType: kotlin.String, getDocStatusRequest: GetDocStatusRequest?) : GetDocStatusResponse {
        val localVariableConfig = postGetDocStatusRequestConfig(contentType = contentType, getDocStatusRequest = getDocStatusRequest)

        val localVarResponse = request<GetDocStatusResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetDocStatusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postGetDocStatus
    *
    * @param contentType  
    * @param getDocStatusRequest ##### Get Document Status Request Model (optional)
    * @return RequestConfig
    */
    fun postGetDocStatusRequestConfig(contentType: kotlin.String, getDocStatusRequest: GetDocStatusRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = getDocStatusRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/GetDocStatus",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Initiate Flow
    * #### Used to initiate aworkflow of a document.
    * @param contentType  
    * @param initiateFlowRequest ##### Initiate Flow Request Model (optional)
    * @return InitiateFlowResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postInitiateFlow(contentType: kotlin.String, initiateFlowRequest: InitiateFlowRequest?) : InitiateFlowResponse {
        val localVariableConfig = postInitiateFlowRequestConfig(contentType = contentType, initiateFlowRequest = initiateFlowRequest)

        val localVarResponse = request<InitiateFlowResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InitiateFlowResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postInitiateFlow
    *
    * @param contentType  
    * @param initiateFlowRequest ##### Initiate Flow Request Model (optional)
    * @return RequestConfig
    */
    fun postInitiateFlowRequestConfig(contentType: kotlin.String, initiateFlowRequest: InitiateFlowRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = initiateFlowRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/InitiateFlow",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Initiate Flow No Email
    * #### Used to initiate a workflow without sending out emails.
    * @param contentType  
    * @param initiateFlowNoEmailRequest ##### Initiate Flow No Email Request Model (optional)
    * @return InitiateFlowNoEmailResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postInitiateFlowNoEmail(contentType: kotlin.String, initiateFlowNoEmailRequest: InitiateFlowNoEmailRequest?) : InitiateFlowNoEmailResponse {
        val localVariableConfig = postInitiateFlowNoEmailRequestConfig(contentType = contentType, initiateFlowNoEmailRequest = initiateFlowNoEmailRequest)

        val localVarResponse = request<InitiateFlowNoEmailResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InitiateFlowNoEmailResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postInitiateFlowNoEmail
    *
    * @param contentType  
    * @param initiateFlowNoEmailRequest ##### Initiate Flow No Email Request Model (optional)
    * @return RequestConfig
    */
    fun postInitiateFlowNoEmailRequestConfig(contentType: kotlin.String, initiateFlowNoEmailRequest: InitiateFlowNoEmailRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = initiateFlowNoEmailRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/InitiateFlow_No_Email",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Initiate Flow No Initial Email
    * #### Used to initiate a document workflow without an initial email being sent to the user.
    * @param contentType  
    * @param initiateFlowNoInitialEmailRequest ##### Initiate Flow No Initial Email Request Model (optional)
    * @return InitiateFlowNoInitialEmailResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postInitiateFlowNoInitialEmail(contentType: kotlin.String, initiateFlowNoInitialEmailRequest: InitiateFlowNoInitialEmailRequest?) : InitiateFlowNoInitialEmailResponse {
        val localVariableConfig = postInitiateFlowNoInitialEmailRequestConfig(contentType = contentType, initiateFlowNoInitialEmailRequest = initiateFlowNoInitialEmailRequest)

        val localVarResponse = request<InitiateFlowNoInitialEmailResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InitiateFlowNoInitialEmailResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postInitiateFlowNoInitialEmail
    *
    * @param contentType  
    * @param initiateFlowNoInitialEmailRequest ##### Initiate Flow No Initial Email Request Model (optional)
    * @return RequestConfig
    */
    fun postInitiateFlowNoInitialEmailRequestConfig(contentType: kotlin.String, initiateFlowNoInitialEmailRequest: InitiateFlowNoInitialEmailRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = initiateFlowNoInitialEmailRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/InitiateFlow_No_Initial_Email",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Workflow Sign
    * #### Used to send a request to a user to sign a document workflow.
    * @param contentType  
    * @param workflowSignRequest ##### Workflow Sign Request Model (optional)
    * @return WorkflowSignResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postWorkflowSign(contentType: kotlin.String, workflowSignRequest: WorkflowSignRequest?) : WorkflowSignResponse {
        val localVariableConfig = postWorkflowSignRequestConfig(contentType = contentType, workflowSignRequest = workflowSignRequest)

        val localVarResponse = request<WorkflowSignResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkflowSignResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation postWorkflowSign
    *
    * @param contentType  
    * @param workflowSignRequest ##### Workflow Sign Request Model (optional)
    * @return RequestConfig
    */
    fun postWorkflowSignRequestConfig(contentType: kotlin.String, workflowSignRequest: WorkflowSignRequest?) : RequestConfig {
        val localVariableBody: kotlin.Any? = workflowSignRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/WorkflowSign",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

}
